import os
import h5py
import numpy as np
import matplotlib.pyplot as plt
import cv2

# Define constants
proc_directory = r'E:\EuXFEL_5157_Data_Part2\proc'
run_id = 121  # Change the run number here
file_name = f'CORR-R{run_id:04d}-HPVX01-S00000.h5'
num_frames = 128  # Total number of frames in the train

# Define the specific train to analyze
train_id = 3

# Construct the proc_directory dynamically
proc_directory = os.path.join(proc_directory, f'r{run_id:04d}')
full_path = os.path.join(proc_directory, file_name)

def get_frame(file_path, train_id, frame_number):
    """Load a specific frame from the HDF5 file."""
    with h5py.File(file_path, "r") as f:
        return f['INSTRUMENT']['SPB_EHD_MIC']['CORR']['HPVX2_1:output']['data']['image']['pixels'][train_id, frame_number]

def apply_roi(image, roi):
    """Apply Region of Interest (ROI) to the frame."""
    x_start, y_start, x_end, y_end = roi
    return image[y_start:y_end, x_start:x_end]

def compute_image_gradients(image1, image2):
    """Compute gradients of image intensity in x, y, and t directions."""
    Ix = cv2.Sobel(image1, cv2.CV_64F, 1, 0, ksize=3)  # Gradient along x
    Iy = cv2.Sobel(image1, cv2.CV_64F, 0, 1, ksize=3)  # Gradient along y
    It = image2 - image1  # Temporal gradient (change over time)
    return Ix, Iy, It

def optical_flow(Ix, Iy, It, alpha=2, num_iter=100):
    """Compute optical flow using the Horn-Schunck method."""
    u = np.zeros_like(Ix)
    v = np.zeros_like(Iy)
    
    # Averaging kernel
    kernel = np.array([[1/12, 1/6, 1/12], [1/6, 0, 1/6], [1/12, 1/6, 1/12]])
    
    for _ in range(num_iter):
        # Compute local averages of u and v
        u_avg = cv2.filter2D(u, -1, kernel)
        v_avg = cv2.filter2D(v, -1, kernel)
        
        # Update flow estimates
        P = (Ix * u_avg + Iy * v_avg + It) / (alpha**2 + Ix**2 + Iy**2 + 1e-5)  # Add a small constant to avoid division by zero
        u = u_avg - Ix * P
        v = v_avg - Iy * P
    
    return u, v

# Convert pixel velocity to meters/second
def convert_to_velocity(u, v, fps, px_size):
    """Convert pixel displacement to velocity in meters/second."""
    # Time between frames (in seconds)
    delta_t = 1 / fps
    # Convert displacement in pixels to displacement in meters
    u_meters_per_sec = (u * px_size) / delta_t
    v_meters_per_sec = (v * px_size) / delta_t
    return u_meters_per_sec, v_meters_per_sec

def visualize_flow_to_image(image, u, v, step=3, title=""):
    """Visualize the optical flow as quiver (vector) plots in meters/second and return the image."""
    fig, ax = plt.subplots(figsize=(8, 6))
    
    # Plot the background image (which is the second frame of the pair)
    ax.imshow(image, cmap='gray')
    
    # Create a mesh grid for plotting the vectors
    h, w = u.shape
    y, x = np.mgrid[0:h, 0:w]
    
    # Subsample u, v, x, and y by the step size
    u_subsampled = u[::step, ::step]
    v_subsampled = v[::step, ::step]
    x_subsampled = x[::step, ::step]
    y_subsampled = y[::step, ::step]
    
    # Calculate the magnitude of the flow
    magnitude = np.sqrt(u_subsampled**2 + v_subsampled**2)
    
    # Create a mask for vectors with magnitude >= half the mean magnitude
    mask = magnitude >= 0.2  # You can adjust the threshold
    
    # Apply the mask to filter the vectors
    u_masked = u_subsampled[mask]
    v_masked = v_subsampled[mask]
    x_masked = x_subsampled[mask]
    y_masked = y_subsampled[mask]
    magnitude_masked = magnitude[mask]
    
    scale_factor = np.max(magnitude_masked) / 15  # Adjust scale factor for better visibility
    
    # Plot the velocity vectors as arrows (quiver plot), color-coded based on magnitude
    quiver_plot = ax.quiver(x_masked, y_masked, u_masked, v_masked, magnitude_masked, 
                            angles='xy', scale_units='xy', scale=scale_factor, cmap='jet')
    
    # Add colorbar to show the magnitude of the velocity vectors in m/s
    plt.colorbar(quiver_plot, label='Velocity Magnitude (m/s)', ax=ax)
    
    # Set title
    ax.set_title(title)
    
    # Convert the plot to an image array using buffer_rgba
    fig.canvas.draw()
    image_from_plot = np.frombuffer(fig.canvas.buffer_rgba(), dtype=np.uint8)
    image_from_plot = image_from_plot.reshape(fig.canvas.get_width_height()[::-1] + (4,))  # Using (4,) for RGBA
    
    # Convert from RGBA to RGB (drop the alpha channel)
    image_from_plot = image_from_plot[..., :3]
    
    plt.close(fig)  # Close the plot to free memory
    
    return image_from_plot

# Parameters for conversion
fps = 1.13e6  # Frames per second
px_size = 3.2e-6  # Pixel size in meters

# Define ROI coordinates (x_start, y_start, x_end, y_end)
roi = (210, 35, 400, 225)  # Example ROI coordinates

# Define video writer for output
output_video = "optical_flow_output4_0.2.mp4"
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Define codec
video_writer = cv2.VideoWriter(output_video, fourcc, fps=10, frameSize=(800, 600))

# Iterate from frame 2 to frame 127
for i in range(2, num_frames - 1):
    # Load consecutive frames
    frame_i = get_frame(full_path, train_id, i)
    frame_next = get_frame(full_path, train_id, i + 1)
    
    # Apply Gaussian filter
    filtered_frame_i = cv2.GaussianBlur(frame_i, (5, 5), 5)
    filtered_frame_next = cv2.GaussianBlur(frame_next, (5, 5), 5)
    
    # Subtract the Gaussian filtered images from the original images
    difference_image_i = cv2.subtract(frame_i, filtered_frame_i)
    difference_image_next = cv2.subtract(frame_next, filtered_frame_next)
    
    # Apply ROI to both frames
    image_i_roi = apply_roi(difference_image_i, roi)
    image_next_roi = apply_roi(difference_image_next, roi)
    
    # Compute image gradients between the two frames
    Ix, Iy, It = compute_image_gradients(image_i_roi, image_next_roi)
    
    # Compute optical flow between the two frames
    u_f, v_f = optical_flow(Ix, Iy, It)
    
    # Convert the flow from pixels to meters/second
    u_f_velocity, v_f_velocity = convert_to_velocity(u_f, v_f, fps, px_size)
    
    # Visualize the flow field for the next frame and convert to image
    flow_image = visualize_flow_to_image(image_next_roi, u_f_velocity, v_f_velocity, title=f"Optical Flow: Frame {i} to Frame {i+1}")
    
    # Write the image to the video
    video_writer.write(cv2.cvtColor(flow_image, cv2.COLOR_RGB2BGR))

# Release the video writer
video_writer.release()

print(f"Video saved as {output_video}")
